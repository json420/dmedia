#!/usr/bin/python3

# dmedia: distributed media library
# Copyright (C) 2011 Novacut Inc
# 
# This file is part of `dmedia`.
# 
# `dmedia` is free software: you can redistribute it and/or modify it under the
# terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
# 
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
# 
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>

import json
import logging
import sys
import time
from copy import deepcopy

from userwebkit import BaseApp
from microfiber import NotFound, Database

import dmedia
from dmedia.util import get_project_db
from dmedia.misc import WeakMethod
from dmedia import views
from dmedia import schema
from dmedia.gtk.util import Timer
from dmedia.service import init_if_needed
from dmedia.service.udisks import Ejector, Formatter
from dmedia.importer import ImportManager, has_magic_lantern
from gi.repository import GObject, Gtk, Gio

try:
    from dmedia.gtk.ubuntu import UnityImportUX
except ImportError:
    UnityImportUX = None


log = dmedia.configure_logging()
init_if_needed()


class Importer:
    def __init__(self, env, proxy, hub):
        super().__init__()
        self.env = env
        self.project_id = env['project_id']
        self.blocking = False
        self.cards = {}
        self.proxy = proxy
        self.proxy.connect_to_signal('CardAdded',
            WeakMethod(self, 'on_CardAdded')
        )
        self.hub = hub
        self.hub.connect('batch_started',
            WeakMethod(self, 'on_batch_started')
        )
        self.hub.connect('batch_progress',
            WeakMethod(self, 'on_batch_progress')
        )
        self.hub.connect('batch_finished',
            WeakMethod(self, 'on_batch_finished')
        )
        self.manager = ImportManager(env, WeakMethod(self, 'callback'))
        local = self.manager.db.get('_local/dmedia')
        self.auto_format = local.get('auto_format', False)
        log.info('auto_format=%r', self.auto_format)
        self.settings = Gio.Settings('org.gnome.desktop.media-handling')
        self.autorun_never = self.settings.get_boolean('autorun-never')
        if not self.autorun_never:
            self.settings.set_boolean('autorun-never', True)

    def __del__(self):
        self.reset()

    def reset(self):
        if not self.autorun_never:
            self.settings.set_boolean('autorun-never', False)

    def callback(self, signal, args):
        GObject.idle_add(self.hub.send, signal, *args)
        
    def on_batch_started(self, hub, batch_id):
        self.count = 0

    def on_batch_progress(self, hub, count, total_count, size, total_size):
        if count > self.count:
            self.count = count
            self.proxy.UpdateProject(self.project_id)

    def on_batch_finished(self, hub, batch_id, stats, copies, msg):
        log.info('batch_finished: %s', batch_id)
        log.info('Calling Dmedia.SnapshotProject(%r)...', self.project_id)
        self.proxy.SnapshotProject(self.project_id)
        self.blocking = True
        self.batch_id = batch_id
        self.copies = copies
        self.stats = stats
        self.msg = msg
        self.workers = {}
        for (obj, mount) in self.cards.items():
            auto_format = self.auto_format and not has_magic_lantern(mount)
            Worker = (Formatter if auto_format else Ejector)
            w = Worker(obj, self.on_complete)
            self.workers[obj] = w
        self.cards.clear()
        for worker in self.workers.values():
            worker.run()
 
    def on_complete(self, worker, obj):
        log.info('Completed: %r', worker)
        w = self.workers.pop(obj)
        assert worker is w
        if len(self.workers) == 0:
            self.blocking = False
            log.info('emitting batch_finalized to UI')
            self.hub.send('batch_finalized',
                self.batch_id, self.stats, self.copies, self.msg
            )

    def on_CardAdded(self, obj, mount, info):
        obj = str(obj)
        mount = str(mount)
        if self.blocking:
            log.warning('Blocking, ignoring card-insert %r', obj)
            return
        log.info('CardAdded %r %r', obj, mount)
        self.cards[obj] = mount
        self.manager.start_import(mount, json.loads(info))


class Replay:
    def __init__(self, filename, hub):
        self.events = json.load(open(filename, 'r'))
        assert isinstance(self.events, list)
        self.i = 0
        self.hub = hub
        self.timer = Timer(1, self.on_timer)
        self.timer.start()

    def on_timer(self):
        if self.i >= len(self.events):
            self.timer.stop()
            return
        (signal, args) = self.events[self.i]
        self.i += 1
        self.hub.send(signal, *args)


WELCOMED_ID = '_local/welcomed'
SETTINGS_ID = '_local/settings'


class App(BaseApp):
    name = 'dmedia'
    dbname = schema.DB_NAME
    version = dmedia.__version__
    title = 'Dmedia'
    page = 'index.html'
    title = 'Dmedia'
    proxy_bus = dmedia.BUS
    importer = None

    signals = {
        'create_project': ['title'],
        'project_created': ['project_id', 'title'],
        'start_importer': ['project_id'],
        'importer_started': ['doc'],
        'stop_importer': [],
        'importer_stopped': [],

        'batch_started': ['batch_id'],
        'import_started': ['basedir', 'import_id', 'extra'],
        'import_scanned': ['basedir', 'import_id', 'total_count', 'total_size'],
        'import_thumbnail': ['basedir', 'import_id', 'doc_id'],
        'batch_progress': ['count', 'total_count', 'size', 'total_size'],
        'batch_finished': ['batch_id', 'stats', 'copies', 'notification'],
        'batch_finalized': ['batch_id', 'stats', 'copies', 'notification'],
        'error': ['error_dict'],
    }

    def connect_hub_signals(self, hub):
        hub.connect('create_project', self.on_create_project)
        hub.connect('start_importer', self.on_start_importer)
        hub.connect('stop_importer', self.on_stop_importer)
        hub.connect('error', self.on_error)

    def dmedia_resolver(self, uri):
        return self.proxy.ResolveURI(uri)

    def create_ux(self):
        if UnityImportUX is not None:
            self.ux = UnityImportUX(self.hub)
            assert sys.getrefcount(self.ux) == 2

    def destroy_ux(self):
        self.ux = None

    def on_error(self, hub, error):
        self.window.present()
        dialog = Gtk.MessageDialog(
            self.window,
            0,
            Gtk.MessageType.ERROR,
            Gtk.ButtonsType.CLOSE,
            'An error occured during the import!\nYour files have not been imported!'
        )
        dialog.run()
        dialog.destroy()

    def on_create_project(self, hub, title):
        doc = schema.create_project(title)
        project = get_project_db(doc['_id'], self.env, True)
        project.post(doc)
        self.db.save(doc)
        GObject.idle_add(self.start_importer, doc)

    def on_start_importer(self, hub, project_id):
        name = schema.project_db_name(project_id)
        pdb = Database(name, ctx=self.db.ctx)
        pdoc = pdb.get(project_id, attachments=True)
        pdoc['atime'] = time.time()
        pdb.save(pdoc)
        try:
            doc = self.db.get(project_id)
            pdoc['_rev'] = doc['_rev']
        except NotFound:
            del pdoc['_rev']
        self.db.save(pdoc)
        GObject.idle_add(self.start_importer, pdoc)

    def start_importer(self, doc):    
        try:
            env = deepcopy(self.env)
            env['project_id'] = doc['_id']
            self.importer = Importer(env, self.proxy, self.hub)
            assert sys.getrefcount(self.importer) == 2
            self.create_ux()
            self.hub.send('importer_started', doc)
        except Exception as e:
            log.exception('exception in on_start_importer()')
            raise e

    def on_stop_importer(self, hub):
        self.importer = None
        self.ux = None
        GObject.idle_add(self.hub.send, 'importer_stopped')


app = App()
try:
    app.run()
finally:
    if app.importer is not None:
        app.importer.reset()
