#!/usr/bin/python3

# dmedia: distributed media library
# Copyright (C) 2011 Novacut Inc
# 
# This file is part of `dmedia`.
# 
# `dmedia` is free software: you can redistribute it and/or modify it under the
# terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
# 
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
# 
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>

import json
import logging
import sys
from urllib.parse import urlparse

from userwebkit import BaseApp
from microfiber import NotFound

import dmedia
from dmedia.gtk import GObject, Gtk
from dmedia.gtk.util import Timer
from dmedia.service.dbus import Ejector, Formatter, UDisks, WeakMethod
from dmedia.service.dbus import extra_info, session
from dmedia.importer import ImportManager
from dmedia.gtk.ubuntu import UnityImportUX
from dmedia import local


log = logging.getLogger()


class ActiveImport(Gtk.VBox):
    def __init__(self):
        super().__init__()
        self._progressbar = Gtk.ProgressBar()
        self.pack_start(self._progressbar, False, False, 2)

    def _set_gmanager(self, gmanager):
        gmanager.connect('batch_progress', self._on_batch_progress)

    def _on_batch_progress(self, gm, count, total_count, size, total_size):
        progress = (0.0 if total_size == 0 else size / total_size)
        self._progressbar.set_property('fraction', progress)


s = """
After starting the importer, dmedia will automatically import all files from any cards you insert.

If you have multiple card readers, you can import multiple cards at the same time.

NOTE THAT DMEDIA IS NOT YET PRODUCTION READY!
THERE WILL STILL BE CHANGES THAT WILL BREAK YOUR DMEDIA DATABASE AND COULD CAUSE DATA LOSS!
"""


class Importer:
    def __init__(self, env, hub):
        super().__init__()
        self.env = env
        self.udisks = UDisks()
        self.udisks.monitor()
        self.udisks.connect('card_inserted',
            WeakMethod(self, 'on_card_inserted')
        )
        self.blocking = False
        self.cards = []
        self.hub = hub
        self.hub.connect('batch_finished',
            WeakMethod(self, 'on_batch_finished')
        )
        self.manager = ImportManager(env, self.callback)

    def callback(self, signal, args):
        GObject.idle_add(self.hub.send, signal, *args)

    def on_batch_finished(self, hub, batch_id, stats, copies, msg):
        Worker = (Formatter if copies >= 2 else Ejector)
        # FIXME: for now, we never use the Formatter just in case.
        Worker = Ejector
        self.blocking = True
        self.batch_id = batch_id
        self.copies = copies
        self.stats = stats
        self.msg = msg
        self.workers = dict(
            (obj, Worker(obj, self.on_complete))
            for obj in self.cards
        )
        self.cards = []
        for worker in self.workers.values():
            worker.run()

    def on_complete(self, worker, obj):
        log.info('Completed: %r', worker)
        w = self.workers.pop(obj)
        assert worker is w
        if len(self.workers) == 0:
            self.blocking = False
            log.info('emitting batch_finalized to UI')
            self.hub.send('batch_finalized',
                self.batch_id, self.stats, self.copies, self.msg
            )

    def on_card_inserted(self, udisks, obj, parentdir, partition, drive):
        if self.blocking:
            log.warning('Blocking, ignoring card-insert %r', obj)
            return
        log.info('card-insert %r', obj)
        self.cards.append(obj)
        info = extra_info(partition, drive)
        self.manager.start_import(parentdir, info)


class Replay:
    def __init__(self, filename, hub):
        self.events = json.load(open(filename, 'r'))
        assert isinstance(self.events, list)
        self.i = 0
        self.hub = hub
        self.timer = Timer(1, self.on_timer)
        self.timer.start()

    def on_timer(self):
        if self.i >= len(self.events):
            self.timer.stop()
            return
        (signal, args) = self.events[self.i]
        self.i += 1
        self.hub.send(signal, *args)


WELCOMED_ID = '_local/welcomed'


class App(BaseApp):
    name = 'dmedia'
    dbname = 'dmedia'
    version = dmedia.__version__
    title = 'Dmedia'
    splash = 'splash.html'
    page = 'index.html'
    title = 'Dmedia'
    proxy_bus = 'org.freedesktop.DMedia'

    signals = {
        'welcome_complete': [],
        'batch_started': ['batch_id'],
        'import_started': ['basedir', 'import_id', 'extra'],
        'import_scanned': ['basedir', 'import_id', 'total_count', 'total_size'],
        'import_thumbnail': ['basedir', 'import_id', 'doc_id'],
        'batch_progress': ['count', 'total_count', 'size', 'total_size'],
        'batch_finished': ['batch_id', 'stats', 'copies', 'notification'],
        'batch_finalized': ['batch_id', 'stats', 'copies', 'notification'],
        'error': ['error_dict'],
    }

    def extend_parser(self, parser):
        parser.add_option('--replay',
            help='replay import',
            action='store_true',
            default=False,
        )

    def connect_hub_signals(self, hub):
        self.importer = None
        self.local = None
        hub.connect('error', self.on_error)
        hub.connect('welcome_complete', self.on_welcome_complete)

    def choose_starting_page(self):
        _id = '_local/welcomed'
        #doc = self.server.get('dmedia', _id)
        #self.server.delete('dmedia', _id, rev=doc['_rev'])
        try:
            self.db.get(WELCOMED_ID)
            return self.page
        except NotFound:
            return 'welcome.html'

    def dmedia_resolver(self, uri):
        if self.env is None:
            return ''
        if self.local is None:
            self.local = local.LocalSlave(self.env)
        try:
            u = urlparse(uri)
            _id = u.path
            doc = self.local.get_doc(_id)
            if doc.get('proxies'):
                proxies = doc['proxies']
                for proxy in proxies:
                    try:
                        st = self.local.stat(proxy)
                        return 'file://' + st.name
                    except (local.NoSuchFile, local.FileNotLocal):
                        pass
            st = self.local.stat2(doc)
            return 'file://' + st.name
        except Exception:    
            return ''

    def on_welcome_complete(self, hub):
        self.db.post({'_id': WELCOMED_ID})
        self.load_page(self.page)

    def set_env(self, env):
        super().set_env(env)
        if env is None:
            return
        if self.options.replay:
            self.create_ux()
            self._replay = Replay('signals.json', self.hub)
        else:
            self.start_importer()

    def start_importer(self):
        self.importer = Importer(self.env, self.hub)
        self.create_ux()

    def create_ux(self):
        self.ux = UnityImportUX(self.hub)

    def destroy_ux(self):
        self.ux = None

    def on_error(self, hub, error):
        self.window.present()
        dialog = Gtk.MessageDialog(
            self.window,
            0,
            Gtk.MessageType.ERROR,
            Gtk.ButtonsType.CLOSE,
            'An error occured during the import!\nYour files have not been imported!'
        )
        dialog.run()
        dialog.destroy()


dmedia.configure_logging()      
app = App()
app.run()
