#!/usr/bin/python3

# dmedia: distributed media library
# Copyright (C) 2011 Novacut Inc
# 
# This file is part of `dmedia`.
# 
# `dmedia` is free software: you can redistribute it and/or modify it under the
# terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
# 
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
# 
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>

import json
import logging
import sys
from copy import deepcopy

from userwebkit import BaseApp
from microfiber import NotFound

import dmedia
from dmedia.util import get_project_db
from dmedia.misc import WeakMethod
from dmedia import views
from dmedia import schema
from dmedia.gtk import GObject, Gtk
from dmedia.gtk.util import Timer
from dmedia.service.udisks import Ejector, Formatter
from dmedia.importer import ImportManager, has_magic_lantern
from gi.repository import GConf

try:
    from dmedia.gtk.ubuntu import UnityImportUX
except ImportError:
    UnityImportUX = None


log = logging.getLogger()
GCONF_KEY = '/apps/nautilus/preferences/media_autorun_never'


class Importer:
    def __init__(self, env, proxy, hub):
        super().__init__()
        self.env = env
        self.blocking = False
        self.cards = {}
        self.proxy = proxy
        self.proxy.connect_to_signal('CardAdded',
            WeakMethod(self, 'on_CardAdded')
        )
        self.hub = hub
        self.hub.connect('batch_finished',
            WeakMethod(self, 'on_batch_finished')
        )
        self.manager = ImportManager(env, WeakMethod(self, 'callback'))
        self.gconf = GConf.Client.get_default()
        self.media_autorun_never = self.gconf.get_bool(GCONF_KEY)
        if not self.media_autorun_never:
            self.gconf.set_bool(GCONF_KEY, True)

    def __del__(self):
        self.reset()

    def reset(self):
        if not self.media_autorun_never:
            self.gconf.set_bool(GCONF_KEY, False)

    def callback(self, signal, args):
        GObject.idle_add(self.hub.send, signal, *args)

    def on_batch_finished(self, hub, batch_id, stats, copies, msg):
        self.blocking = True
        self.batch_id = batch_id
        self.copies = copies
        self.stats = stats
        self.msg = msg
        self.workers = {}
        for (obj, mount) in self.cards.items():
            Worker = (Ejector if has_magic_lantern(mount) else Formatter)
            #Worker = Ejector
            w = Worker(obj, self.on_complete)
            self.workers[obj] = w
        self.cards.clear()
        for worker in self.workers.values():
            worker.run()

    def on_complete(self, worker, obj):
        log.info('Completed: %r', worker)
        w = self.workers.pop(obj)
        assert worker is w
        if len(self.workers) == 0:
            self.blocking = False
            log.info('emitting batch_finalized to UI')
            self.hub.send('batch_finalized',
                self.batch_id, self.stats, self.copies, self.msg
            )

    def on_CardAdded(self, obj, mount, info):
        if self.blocking:
            log.warning('Blocking, ignoring card-insert %r', obj)
            return
        log.info('CardAdded %r %r', obj, mount)
        self.cards[obj] = mount
        self.manager.start_import(mount, json.loads(info))


class Replay:
    def __init__(self, filename, hub):
        self.events = json.load(open(filename, 'r'))
        assert isinstance(self.events, list)
        self.i = 0
        self.hub = hub
        self.timer = Timer(1, self.on_timer)
        self.timer.start()

    def on_timer(self):
        if self.i >= len(self.events):
            self.timer.stop()
            return
        (signal, args) = self.events[self.i]
        self.i += 1
        self.hub.send(signal, *args)


WELCOMED_ID = '_local/welcomed'
SETTINGS_ID = '_local/settings'


class App(BaseApp):
    name = 'dmedia'
    dbname = schema.DB_NAME
    version = dmedia.__version__
    title = 'Dmedia'
    page = 'index.html'
    title = 'Dmedia'
    proxy_bus = dmedia.BUS
    importer = None

    signals = {
        'create_project': ['title'],
        'project_created': ['project_id', 'title'],
        'start_importer': ['project_id'],
        'importer_started': ['project_db_name'],
        'stop_importer': [],
        'importer_stopped': [],

        'onboard_complete': [],
        'batch_started': ['batch_id'],
        'import_started': ['basedir', 'import_id', 'extra'],
        'import_scanned': ['basedir', 'import_id', 'total_count', 'total_size'],
        'import_thumbnail': ['basedir', 'import_id', 'doc_id'],
        'batch_progress': ['count', 'total_count', 'size', 'total_size'],
        'batch_finished': ['batch_id', 'stats', 'copies', 'notification'],
        'batch_finalized': ['batch_id', 'stats', 'copies', 'notification'],
        'error': ['error_dict'],
    }

    def extend_parser(self, parser):
#        parser.add_option('--replay',
#            help='replay import',
#            action='store_true',
#            default=False,
#        )
        parser.add_option('--onboard',
            help='force run of onboarding experience',
            action='store_true',
            default=False,
        )

    def connect_hub_signals(self, hub):
        hub.connect('create_project', self.on_create_project)
        hub.connect('start_importer', self.on_start_importer)
        hub.connect('stop_importer', self.on_stop_importer)
        hub.connect('error', self.on_error)
        hub.connect('onboard_complete', self.on_onboard_complete)

    def choose_starting_page(self):
        try:
            doc = self.db.get(SETTINGS_ID)
        except NotFound:
            doc = {
                '_id': SETTINGS_ID,
                'onboarded': False,
            }
            self.db.save(doc)
        if self.options.onboard:
            doc['onboarded'] = False
            self.db.save(doc)
        if doc.get('onboarded'):
            return self.page
        else:
            return 'dont_panic.html'

    def dmedia_resolver(self, uri):
        return self.proxy.ResolveURI(uri)

    def on_onboard_complete(self, hub):
        doc = self.db.get(SETTINGS_ID)
        doc['onboarded'] = True
        self.db.save(doc)
        self.load_page(self.page)

    def create_ux(self):
        if UnityImportUX is not None:
            self.ux = UnityImportUX(self.hub)
            assert sys.getrefcount(self.ux) == 2

    def destroy_ux(self):
        self.ux = None

    def on_error(self, hub, error):
        self.window.present()
        dialog = Gtk.MessageDialog(
            self.window,
            0,
            Gtk.MessageType.ERROR,
            Gtk.ButtonsType.CLOSE,
            'An error occured during the import!\nYour files have not been imported!'
        )
        dialog.run()
        dialog.destroy()

    def on_start_importer(self, dub, project_id):
        try:
            env = deepcopy(self.env)
            env['project_id'] = project_id
            self.importer = Importer(env, self.proxy, self.hub)
            assert sys.getrefcount(self.importer) == 2
            self.create_ux()
            self.hub.send('importer_started', schema.project_db_name(project_id))
        except Exception as e:
            log.exception('exception in on_start_importer()')
            raise e

    def on_stop_importer(self, hub):
        self.importer = None
        self.ux = None
        self.hub.send('importer_stopped')

    def on_create_project(self, hub, title):
        print(repr(title))
        doc = schema.create_project(title)
        self.db.post(doc)
        project = get_project_db(doc['_id'], self.env, True)
        project.save(doc)
        self.hub.send('project_created', doc['_id'], doc['title'])


dmedia.configure_logging()      
app = App()
try:
    app.run()
finally:
    if app.importer is not None:
        app.importer.reset()
