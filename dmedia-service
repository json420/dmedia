#!/usr/bin/python3

# dmedia: distributed media library
# Copyright (C) 2011 Novacut Inc
#
# This file is part of `dmedia`.
#
# `dmedia` is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>

"""
Dmedia DBus service on org.freedesktop.Dmedia.
"""

import time
start_time = time.time()

import optparse
import logging
import signal

import dbus
import dbus.service
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GObject
from microfiber import NotFound, dumps

import dmedia
from dmedia.parallel import start_thread
from dmedia.startup import DmediaCouch
from dmedia.core import Core, start_httpd
from dmedia.service.udisks import UDisks
from dmedia.service.avahi import Avahi
from dmedia.service.peers import Browser, ClientUI


BUS = dmedia.BUS
IFACE = BUS
log = logging.getLogger()
GObject.threads_init()
DBusGMainLoop(set_as_default=True)
session = dbus.SessionBus()
mainloop = GObject.MainLoop()


def on_sighup(signum, frame):
    log.info('<SIGHUP>')
    mainloop.quit()

signal.signal(signal.SIGHUP, on_sighup)



def create_machine(couch):
    couch.create_machine()


class Service(dbus.service.Object):
    couch = None
    httpd = None
    avahi = None
    peer = None
    ui = None
    mthread = None
    thread = None
    env_s = '{}'

    def __init__(self, bus, couch):
        self.bus = bus
        self.couch = couch
        super().__init__(session, object_path='/')
        log.info('DBus: binding to %r', bus)
        self.busname = dbus.service.BusName(bus, session)
        session.call_on_disconnection(self.on_disconnection)
        self.udisks = UDisks()
        self.udisks.connect('store_added', self.on_store_added)
        self.udisks.connect('store_removed', self.on_store_removed)
        self.udisks.connect('card_added', self.on_card_added)
        self.udisks.connect('card_removed', self.on_card_removed)

    def run(self):
        if self.couch.isfirstrun():
            log.info('First run, not starting CouchDB.')
            if self.couch.machine is None:
                self.mthread = start_thread(create_machine, self.couch)
        else:
            self.start_core()
        mainloop.run()

    def start_core(self):
        start = time.time()
        env = self.couch.auto_bootstrap()
        log.info('%r', self.couch._welcome)
        log.info('Starting CouchDB took %.3f', time.time() - start)
        self.core = Core(env)
        self.core.load_identity(self.couch.machine, self.couch.user)
        self.core.init_default_store()
        if self.core.local.get('default_store') is None:
            self.core.set_default_store('shared')
        self.env_s = dumps(self.core.env, pretty=True)
        log.info('Finished core startup in %.3f', time.time() - start)
        GObject.timeout_add(500, self.on_idle1)

    def start_httpd(self):
        ssl_config = self.couch.get_ssl_config()
        (self.httpd, env) = start_httpd(self.core.env, ssl_config)
        port = env['port']
        self.avahi = Avahi(self.core.env, port, ssl_config)
        self.avahi.run()
        if self.couch.pki.user.key_file is not None:
            self.peer = Browser(self.couch)

    def on_idle1(self):
        log.info('[idle1]')
        self.udisks.monitor()
        GObject.timeout_add(500, self.on_idle2)
        return False  # Don't repeat idle call

    def on_idle2(self):
        log.info('[idle2]')
        self.start_httpd()
        GObject.timeout_add(1000, self.on_idle3)
        return False  # Don't repeat idle call

    def on_idle3(self):
        log.info('[idle3]')
        start_thread(self.core.init_project_views)
        self.core.start_background_tasks()
        return False  # Don't repeat idle call

    def on_disconnection(self, bus):
        log.info('<DBus disconnection>')
        self.shutdown()

    def shutdown(self):
        log.info('Service.shutdown()')
        if self.peer is not None:
            log.info('* freeing peer')
            self.peer.free()
            self.peer = None
        if self.avahi is not None:
            log.info('* freeing avahi')
            self.avahi.free()
            self.avahi = None
        if self.httpd is not None:
            log.info('* killing httpd')
            self.httpd.terminate()
            self.httpd.join()
            self.httpd = None
        if self.couch is not None:
            log.info('* killing usercouch')
            self.couch.kill()
            self.couch = None

    def on_store_added(self, udisks, obj, parentdir, store_id, info):
        try:
            self.core.connect_filestore(parentdir, store_id)
        except Exception:
            log.exception('Could not connect FileStore %r', parentdir)

    def on_store_removed(self, udisks, obj, parentdir, store_id):
        try:
            self.core.disconnect_filestore(parentdir, store_id)
        except Exception:
            log.exception('Could not disconnect FileStore %r', parentdir)

    def on_card_added(self, udisks, obj, mount, info):
        self.CardAdded(obj, mount, dumps(info))

    def on_card_removed(self, udisks, obj, mount):
        self.CardRemoved(obj, mount)

    @dbus.service.signal(IFACE, signature='sss')
    def CardAdded(self, obj, mount, info):
        pass

    @dbus.service.signal(IFACE, signature='ss')
    def CardRemoved(self, obj, mount):
        pass

    @dbus.service.signal(IFACE, signature='s')
    def InitDone(self, env_s):
        pass

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def Version(self):
        """
        Return dmedia version.
        """
        return dmedia.__version__

    @dbus.service.method(IFACE, in_signature='', out_signature='b')
    def NeedsInit(self):
        """
        Return True if we need to do the firstrun init.
        """
        return self.couch.isfirstrun()

    @dbus.service.method(IFACE, in_signature='', out_signature='b')
    def DoInit(self):
        """
        Return dmedia version.
        """
        log.info('Dmedia.DoInit()')
        if self.ui is None:
            if self.mthread is not None:
                self.mthread.join()
                self.mthread = None
            self.couch.load_pki()
            self.ui = ClientUI(self.couch)
            self.ui.window.connect('delete-event', self.on_delete_event)
            self.ui.hub.connect('first_time', self.on_first_time)
            self.ui.hub.connect('done', self.on_done)
            self.ui.window.show_all()
            return True
        else:
            return False

    def on_first_time(self, hub):
        log.info('on_first_time()')
        if self.thread is None:
            self.thread = start_thread(self.do_create_user)

    def on_delete_event(self, *args):
        log.info('on_delete_event()')
        if self.thread is None:
            self.thread = start_thread(self.do_create_user)

    def on_done(self, hub, user_id):
        log.info('on_done(%r)', user_id)
        if self.thread is None:
            self.thread = start_thread(self.do_set_user, user_id)

    def do_create_user(self):
        log.info('do_create_user()')
        self.couch.create_user()
        self.start_core()
        GObject.idle_add(self.do_destroy)

    def do_set_user(self, user_id):
        log.info('do_set_user(%r)', user_id)
        self.couch.set_user(user_id)
        self.start_core()
        GObject.idle_add(self.do_destroy)

    def do_destroy(self):
        log.info('do_destroy()')
        self.thread.join()
        self.ui.window.destroy()
        self.ui = None
        self.InitDone(self.env_s)
        self.thread = None

    @dbus.service.method(IFACE, in_signature='', out_signature='i')
    def Kill(self):
        """
        Kill the `dmedia-service` process.
        """
        log.info('Service.Kill()')
        mainloop.quit()
        return int(time.time() - start_time)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def GetEnv(self):
        """
        Return dmedia env as JSON string.
        """
        log.info('Service.GetEnv()')
        return self.env_s

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def GetDiskInfo(self):
        """
        Return Dmedia-friendly info on disks from UDisks, as a JSON string.
        """
        return dumps(self.udisks.info)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def LocalDmedia(self):
        """
        Return the _local/dmedia doc.
        """
        return dumps(self.core.db.get('_local/dmedia'))

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def Peers(self):
        """
        Return the _local/peers doc.
        """
        try:
            doc = self.core.db.get('_local/peers')
            return dumps(doc['peers'], pretty=True)
        except NotFound:
            return '{}'

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def CreateFileStore(self, parentdir):
        parentdir = str(parentdir)
        log.info('Dmedia.CreateFileStore(%r)', parentdir)
        self.core.create_filestore(parentdir)
        return self.LocalDmedia()

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def SetDefaultStore(self, value):
        value = str(value)
        log.info('Dmedia.SetDefaultStore(%r)', value)
        self.core.set_default_store(value)
        return self.LocalDmedia()

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def Resolve(self, _id):
        return self.core.resolve(_id)

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def ResolveURI(self, uri):
        return self.core.resolve_uri(uri)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def AllocateTmp(self):
        return self.core.allocate_tmp()

    @dbus.service.method(IFACE, in_signature='ss', out_signature='a{ss}')
    def HashAndMove(self, tmp, origin):
        return self.core.hash_and_move(tmp, origin)

    @dbus.service.method(IFACE, in_signature='s', out_signature='')
    def Snapshot(self, dbname):
        self.core.snapshot(self.couch.paths.dump, str(dbname))

    @dbus.service.method(IFACE, in_signature='', out_signature='')
    def SnapshotAll(self):
        self.core.snapshot_all(self.couch.paths.dump)


parser = optparse.OptionParser(
	version=dmedia.__version__,
)
parser.add_option('--bus',
    help='DBus bus name; default is {!r}'.format(BUS),
    default=BUS
)
(options, args) = parser.parse_args()


# Before we do anything else, aquire the UserCouch lock:
couch = DmediaCouch(dmedia.get_dmedia_dir())

# Now go for it:
dmedia.configure_logging()
try:
    service = Service(options.bus, couch)
    try:
        service.run()
    finally:
        service.shutdown()
except Exception as e:
    log.exception('Could not start dmedia-service!')
    raise e
