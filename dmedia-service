#!/usr/bin/python3

# dmedia: distributed media library
# Copyright (C) 2011 Novacut Inc
#
# This file is part of `dmedia`.
#
# `dmedia` is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>

"""
Dmedia DBus service on org.freedesktop.Dmedia.
"""

import time
start_time = time.time()

import optparse
import logging
import json
from os import path

import dbus
import dbus.service
from dbus.mainloop.glib import DBusGMainLoop
from microfiber import Database, NotFound
from filestore import _start_thread
import usercouch
from gi.repository import GObject

import dmedia
from dmedia.core import Core, start_file_server
from dmedia.service.udisks import UDisks
from dmedia.service.avahi import Avahi
from dmedia.service.replicator import Replicator


BUS = dmedia.BUS
IFACE = BUS
log = logging.getLogger()

GObject.threads_init()
DBusGMainLoop(set_as_default=True)
session = dbus.SessionBus()


def dumps(obj):
    return json.dumps(obj, sort_keys=True, separators=(',', ': '), indent=4)


def get_config(f):
    try:
        return json.load(open(f, 'r'))
    except Exception:
        pass


class Service(dbus.service.Object):
    usercouch = None
    httpd = None
    avahi = None
    replicator = None

    def __init__(self, bus, env_s):
        self.bus = bus
        self.env_s = env_s
        self.mainloop = GObject.MainLoop()
        log.info('DBus: binding to %r', bus)
        super().__init__(session, object_path='/')
        self.busname = dbus.service.BusName(bus, session)
        self.udisks = UDisks()
        self.udisks.connect('store_added', self.on_store_added)
        self.udisks.connect('store_removed', self.on_store_removed)
        self.udisks.connect('card_added', self.on_card_added)
        self.udisks.connect('card_removed', self.on_card_removed)

    def start_core(self):
        if self.env_s is None:
            self.usercouch = usercouch.UserCouch(dmedia.get_dmedia_dir())
            f = path.join(self.usercouch.basedir, 'library.json')
            self.config = get_config(f)
            start = time.time()
            if self.config is None:
                env = self.usercouch.bootstrap()
            else:
                env = self.usercouch.bootstrap2(self.config['tokens'])
            log.info('Starting CouchDB took %r', time.time() - start)
            log.info(repr(self.usercouch.server.get()))
        else:
            self.config = None
            env = json.loads(self.env_s)
        self.core = Core(env)
        self.env_s = dumps(self.core.env)

    def start_httpd(self):
        (self.httpd, self.port) = start_file_server(self.core.env)
        self.avahi = Avahi(self.core.env, self.port)
        self.avahi.run()
        if self.config is not None:
            self.replicator = Replicator(self.core.env, self.config)
            self.replicator.run()

    def run(self):
        self.start_core()
        log.info('Finished core startup in %r', time.time() - start_time)
        GObject.timeout_add(2000, self.on_idle1)
        self.mainloop.run()

    def on_idle1(self):
        log.info('[idle1]')
        self.udisks.monitor()
        _start_thread(self.core.init_project_views)
        GObject.timeout_add(4000, self.on_idle2)
        return False  # Don't repeat idle call

    def on_idle2(self):
        log.info('[idle2]')
        self.start_httpd()
        self.core.start_background_tasks()
        interval = 5 * 60 * 1000  # Autocompact every 5 minutes
        self._timeout_id = GObject.timeout_add(interval, self._autocompact)
        return False  # Don't repeat idle call

    def _autocompact(self):
        log.info('UserCouch.autocompact()...')
        try:
            for name in self.usercouch.autocompact():
                log.info('compacting %r', name)
        except Exception as e:
            log.exception('Error calling UserCouch.autocompact():')
        return True  # Repeat timeout call

    def shutdown(self):
        log.info('Service.shutdown()')
        if self.usercouch is not None:
            log.info('* killing usercouch')
            self.usercouch.kill()
        if self.avahi is not None:
            log.info('* freeing avahi')
            self.avahi.free()
        if self.replicator is not None:
            log.info('* freeing replicator')
            self.replicator.free()
        if self.httpd is not None:
            log.info('* killing httpd')
            self.httpd.terminate()
            self.httpd.join()

    def on_store_added(self, udisks, obj, parentdir, store_id, info):
        try:
            self.core.connect_filestore(parentdir, store_id)
        except Exception:
            log.exception('Could not connect FileStore %r', parentdir)

    def on_store_removed(self, udisks, obj, parentdir, store_id):
        try:
            self.core.disconnect_filestore(parentdir, store_id)
        except Exception:
            log.exception('Could not disconnect FileStore %r', parentdir)

    def on_card_added(self, udisks, obj, mount, info):
        self.CardAdded(obj, mount, dumps(info))

    def on_card_removed(self, udisks, obj, mount):
        self.CardRemoved(obj, mount)

    @dbus.service.signal(IFACE, signature='sss')
    def CardAdded(self, obj, mount, info):
        pass

    @dbus.service.signal(IFACE, signature='ss')
    def CardRemoved(self, obj, mount):
        pass

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def Version(self):
        """
        Return dmedia version.
        """
        return dmedia.__version__

    @dbus.service.method(IFACE, in_signature='', out_signature='i')
    def Kill(self):
        """
        Kill the `dmedia-service` process.
        """
        log.info('Service.Kill()')
        self.mainloop.quit()
        return int(time.time() - start_time)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def GetEnv(self):
        """
        Return dmedia env as JSON string.
        """
        log.info('Service.GetEnv()')
        return self.env_s

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def GetDiskInfo(self):
        """
        Return Dmedia-friendly info on disks from UDisks, as a JSON string.
        """
        return dumps(self.udisks.info)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def LocalDmedia(self):
        """
        Return the _local/dmedia doc.
        """
        return dumps(self.core.db.get('_local/dmedia'))

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def LocalPeers(self):
        """
        Return the _local/peers doc.
        """
        try:
            return dumps(self.core.db.get('_local/peers'))
        except NotFound:
            return '{}'

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def CreateFileStore(self, parentdir):
        self.core.create_filestore(str(parentdir))
        return self.LocalDmedia()

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def Resolve(self, _id):
        return self.core.resolve(_id)

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def ResolveURI(self, uri):
        return self.core.resolve_uri(uri)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def AllocateTmp(self):
        return self.core.allocate_tmp()

    @dbus.service.method(IFACE, in_signature='ss', out_signature='a{ss}')
    def HashAndMove(self, tmp, origin):
        return self.core.hash_and_move(tmp, origin)


parser = optparse.OptionParser(
	version=dmedia.__version__,
)
parser.add_option('--env',
    help='JSON-encoded CouchDB environment (for unit testing)',
)
parser.add_option('--bus',
    help='DBus bus name; default is {!r}'.format(BUS),
    default=BUS
)
(options, args) = parser.parse_args()


dmedia.configure_logging()
service = Service(options.bus, options.env)
try:
    service.run()
finally:
    service.shutdown()
