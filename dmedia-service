#!/usr/bin/python3

# dmedia: distributed media library
# Copyright (C) 2011 Novacut Inc
#
# This file is part of `dmedia`.
#
# `dmedia` is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>

"""
Dmedia DBus service on org.freedesktop.Dmedia.
"""

import time
start_time = time.time()

import optparse
import logging
import signal

import dbus
import dbus.service
from gi.repository import GLib, Gio
from microfiber import NotFound, dumps

import dmedia
from dmedia import schema
from dmedia.units import bytes10
from dmedia.util import get_filestore_id
from dmedia.parallel import start_thread
from dmedia.startup import DmediaCouch
from dmedia.core import Core, start_httpd
from dmedia.service.background import Snapshots, LazyAccess, Downloads
from dmedia.service.avahi import Avahi
from dmedia.service.peers import Browser, Publisher


BUS = dmedia.BUS
IFACE = BUS
log = logging.getLogger()
session = dbus.SessionBus()
mainloop = GLib.MainLoop()
VolumeMonitor = Gio.VolumeMonitor.get()


def on_sighup(signum, frame):
    log.info('<SIGHUP>')
    mainloop.quit()

signal.signal(signal.SIGHUP, on_sighup)


class Service(dbus.service.Object):
    couch = None
    httpd = None
    avahi = None
    peer = None
    ui = None
    thread = None
    publisher = None
    env_s = '{}'

    def __init__(self, busname):
        super().__init__(busname, object_path='/')

        # Before we do anything else, aquire the UserCouch lock:
        self.couch = DmediaCouch(dmedia.get_dmedia_dir())

        # Now go for it:
        dmedia.configure_logging()
        self.first_snapshot = True
        self.update_thread = None
        self.pending_update = None

        try:
            self.manager = session.get_object(
                'org.gnome.SessionManager', '/org/gnome/SessionManager'
            )
            self.client_obj = self.manager.RegisterClient('dmedia-service', '',
                dbus_interface='org.gnome.SessionManager'
            )
            self.client = session.get_object(
                'org.gnome.SessionManager', self.client_obj
            )
            self.client.connect_to_signal(
                'QueryEndSession', self.on_QueryEndSession,
                dbus_interface='org.gnome.SessionManager.ClientPrivate'
            )
            self.client.connect_to_signal('EndSession', self.on_EndSession,
                dbus_interface='org.gnome.SessionManager.ClientPrivate'
            )
            self.client.connect_to_signal('Stop', self.on_Stop,
                dbus_interface='org.gnome.SessionManager.ClientPrivate'
            )
        except dbus.DBusException:
            log.warning('org.gnome.SessionManager not available')

    def on_QueryEndSession(self, flags):
        log.info('<QueryEndSession>')
        self.client.EndSessionResponse(True, '',
            dbus_interface='org.gnome.SessionManager.ClientPrivate'
        )

    def on_EndSession(self, flags):
        log.info('<EndSession>')
        self.shutdown()
        self.client.EndSessionResponse(True, '',
            dbus_interface='org.gnome.SessionManager.ClientPrivate'
        )

    def on_Stop(self):
        log.info('<Stop>')
        self.manager.UnregisterClient(self.client_obj,
            dbus_interface='org.gnome.SessionManager'
        )
        mainloop.quit()

    @dbus.service.signal(IFACE, signature='sb')
    def SnapshotComplete(self, name, success):
        log.info('@Dmedia.SnapshotComplete(%r, %r)', name, success)
        if name == '__all__':
            self.SnapshotAllComplete(success)

    @dbus.service.signal(IFACE, signature='b')
    def SnapshotAllComplete(self, success):
        log.info('@Dmedia.SnapshotAllComplete(%r)', success)
        if self.first_snapshot:
            self.first_snapshot = False
            start_thread(self.init_views)

    @dbus.service.method(IFACE, in_signature='s', out_signature='b')
    def Snapshot(self, name):
        name = str(name)
        log.info('Dmedia.Snapshot(%r)', name)
        return self.snapshots.run(name)

    @dbus.service.method(IFACE, in_signature='', out_signature='b')
    def SnapshotAll(self):
        log.info('Dmedia.SnapshotAll()')
        return self.Snapshot('__all__')

    def run(self):
        if self.couch.user is None:
            log.info('First run, not starting CouchDB.')
            self.couch.create_machine_if_needed()
        else:
            self.start_core()
        mainloop.run()

    def start_core(self):
        start = time.time()
        env = self.couch.auto_bootstrap()
        log.info('%r', self.couch._welcome)
        log.info('Starting CouchDB took %.3f', time.time() - start)
        self.core = Core(env, self.couch.get_ssl_config())
        d = self.core.db.get()
        log.info('doc_count: %s, update_seq: %s, data_size: %s, disk_size: %s',
            d['doc_count'],
            d['update_seq'],
            bytes10(d['data_size']),
            bytes10(d['disk_size']),
        )
        self.core.load_identity(self.couch.machine, self.couch.user)
        self.core.load_default_filestore(self.couch.basedir)
        self.env_s = dumps(self.core.env, pretty=True)
        self.snapshots = Snapshots(
                self.core.env,
                self.couch.paths.dump,
                self.SnapshotComplete,
        )
        self.lazy_access = LazyAccess(self.core.db)
        self.downloads = Downloads(self.core.env, self.couch.get_ssl_config())
        log.info('Finished core startup in %.3f', time.time() - start)
        GLib.timeout_add(350, self.on_idle1)

    def on_idle1(self):
        """
        VolumeMontior, peering browser, and SnapshotAll.
        """
        log.info('[idle1 at time %.3f]', time.time() - start_time)
        if self.couch.pki.user.key_file is not None:
            self.peer = Browser(self, self.couch)
        VolumeMonitor.connect('mount-added', self.on_mount_added)
        VolumeMonitor.connect('mount-removed', self.on_mount_removed)
        for mount in VolumeMonitor.get_mounts():
            self.on_mount_added(VolumeMonitor, mount)
        self.SnapshotAll()

    def init_views(self):
        """
        Init project views, prep project/atime, update project stats.
        """
        self.core.init_project_views()
        GLib.idle_add(self.on_idle2)

    def on_idle2(self):
        """
        Start HTTPD, Avahi, replication.
        """
        log.info('[idle2 at time %.3f]', time.time() - start_time)
        ssl_config = self.couch.get_ssl_config()
        (self.httpd, env) = start_httpd(self.core.env, ssl_config)
        port = env['port']
        self.avahi = Avahi(self.core.env, port, ssl_config)
        self.avahi.run()
        GLib.timeout_add(30 * 1000, self.on_idle3)

    def on_idle3(self):
        """
        Start the background filestore checking tasks.
        """
        log.info('[idle3 at time %.3f]', time.time() - start_time)
        self.core.start_background_tasks()
        GLib.timeout_add(30 * 60 * 1000, self.on_background_restart)

    def on_background_restart(self):
        log.info('on_background_restart()')
        self.core.restart_background_tasks()
        return True

    def shutdown(self):
        log.info('Service.shutdown()')
        if self.peer is not None:
            log.info('* freeing peer')
            self.peer.free()
            self.peer = None
        if self.avahi is not None:
            log.info('* freeing avahi')
            self.avahi.free()
            self.avahi = None
        if self.httpd is not None:
            log.info('* killing httpd')
            self.httpd.terminate()
            self.httpd.join()
            self.httpd = None
        if self.couch is not None:
            log.info('* killing usercouch')
            if hasattr(self, 'lazy_access'):
                self.lazy_access.flush()
            self.couch.kill()
            self.couch = None

    def on_mount_added(self, vm, mount):
        parentdir = mount.get_root().get_path()
        log.info('mount_added: %r', parentdir)
        store_id = get_filestore_id(parentdir)
        if store_id is None:
            log.warning('%r is not a filestore, skipping', parentdir)
            return
        try:
            self.core.connect_filestore(parentdir, store_id)
        except Exception:
            log.exception('Could not connect FileStore %r', parentdir)

    def on_mount_removed(self, vm, mount):
        parentdir = mount.get_root().get_path()
        log.info('mount_removed: %r', parentdir)
        try:
            fs = self.core.stores.by_parentdir(parentdir)
            self.core.disconnect_filestore(parentdir, fs.id)
        except KeyError:
            log.warning('%r is not a connected filestore', parentdir)

    ###########################################
    # Signals and Methods for Peering Protocol:

    @dbus.service.signal(IFACE, signature='s')
    def Message(self, message):
        log.info('@Dmedia.Message(%r)', message)

    @dbus.service.signal(IFACE, signature='sb')
    def DisplaySecret(self, secret, typo):
        log.info('@Dmedia.DisplaySecret(<secret>, %r)', typo)

    @dbus.service.method(IFACE, in_signature='s', out_signature='b')
    def GetSecret(self, peer_id):
        log.info('Dmedia.GetSecret(%r)', peer_id)
        if self.peer is None:
            return False
        return self.peer.get_secret(peer_id)

    @dbus.service.method(IFACE, in_signature='s', out_signature='b')
    def Cancel(self, peer_id):
        log.info('Dmedia.Cancel(%r)', peer_id)
        if self.peer is None:
            return False
        GLib.idle_add(self.peer.cancel, peer_id)
        return True

    @dbus.service.signal(IFACE, signature='')
    def Accept(self):
        log.info('@Dmedia.Accept()')

    @dbus.service.signal(IFACE, signature='b')
    def Response(self, success):
        log.info('@Dmedia.Response(%r)', success)

    @dbus.service.signal(IFACE, signature='')
    def InitDone(self):
        log.info('@Dmedia.InitDone()')

    @dbus.service.signal(IFACE, signature='')
    def PeeringDone(self):
        log.info('@Dmedia.PeeringDone()')

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def Version(self):
        """
        Return dmedia version.
        """
        return dmedia.__version__

    @dbus.service.method(IFACE, in_signature='', out_signature='b')
    def NeedsInit(self):
        """
        Return True if we need to do the firstrun init.
        """
        return self.couch.user is None

    @dbus.service.method(IFACE, in_signature='', out_signature='b')
    def CreateUser(self):
        log.info('Dmedia.CreateUser()')
        if self.couch.user is not None:
            return False
        if self.thread is not None:
            return False
        self.thread = start_thread(self.create_user)
        return True

    def create_user(self):
        log.info('create_user()')
        self.couch.wait_for_machine()
        self.couch.create_user()
        self.start_core()
        GLib.idle_add(self.on_init_done)

    def on_init_done(self):
        log.info('on_init_done()')
        self.thread.join()
        self.thread = None
        if self.publisher is not None:
            self.publisher.free()
            self.publisher = None
        self.InitDone()

    @dbus.service.method(IFACE, in_signature='', out_signature='b')
    def PeerWithExisting(self):
        log.info('Dmedia.PeerWithExisting()')
        if self.couch.user is not None:
            return False
        if self.publisher is not None:
            return False
        if self.thread is not None:
            return False
        self.publisher = Publisher(self, self.couch)
        self.thread = start_thread(self.wait)
        return True

    def wait(self):
        self.couch.wait_for_machine()
        GLib.idle_add(self.on_wait_done)

    def on_wait_done(self):
        self.thread.join()
        self.thread = None
        self.publisher.run()

    @dbus.service.method(IFACE, in_signature='s', out_signature='b')
    def SetSecret(self, secret):
        log.info('Dmedia.SetSecret()')
        return self.publisher.set_secret(secret)

    def set_user(self, user_id):
        log.info('set_user(%r)', user_id)
        assert self.couch.user is None
        assert self.thread is None
        self.thread = start_thread(self._set_user, user_id)

    def _set_user(self, user_id):
        self.couch.set_user(user_id)
        self.start_core()
        GLib.idle_add(self.on_init_done)

    @dbus.service.method(IFACE, in_signature='', out_signature='i')
    def Kill(self):
        """
        Kill the `dmedia-service` process.
        """
        log.info('Service.Kill()')
        mainloop.quit()
        return int(time.time() - start_time)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def GetEnv(self):
        """
        Return dmedia env as JSON string.
        """
        log.info('Service.GetEnv()')
        return self.env_s

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def Stores(self):
        """
        Return currently connected filestores
        """
        return dumps(self.core.local['stores'], pretty=True)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def Peers(self):
        """
        Return the _local/peers doc.
        """
        try:
            doc = self.core.db.get('_local/peers')
            return dumps(doc['peers'], pretty=True)
        except NotFound:
            return '{}'

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def CreateFileStore(self, parentdir):
        parentdir = str(parentdir)
        log.info('Dmedia.CreateFileStore(%r)', parentdir)
        self.core.create_filestore(parentdir)
        return self.Stores()

    @dbus.service.method(IFACE, in_signature='s', out_signature='')
    def DowngradeStore(self, store_id):
        store_id = str(store_id)
        log.info('Dmedia.DowngradeStore(%r)', store_id)
        start_thread(self.core.downgrade_store, store_id)

    @dbus.service.method(IFACE, in_signature='', out_signature='')
    def DowngradeAll(self):
        log.info('Dmedia.DowngradeAll()')
        start_thread(self.core.ms.downgrade_all)

    @dbus.service.method(IFACE, in_signature='s', out_signature='')
    def PurgeStore(self, store_id):
        store_id = str(store_id)
        log.info('Dmedia.PurgeStore(%r)', store_id)
        start_thread(self.core.purge_store, store_id)

    @dbus.service.method(IFACE, in_signature='', out_signature='')
    def PurgeAll(self):
        log.info('Dmedia.PurgeAll()')
        start_thread(self.core.ms.purge_all)

    @dbus.service.method(IFACE, in_signature='s', out_signature='(sys)')
    def Resolve(self, file_id):
        (file_id, status, filename) = self.core.resolve(file_id)
        if status in (0, 1):
            self.lazy_access.access(file_id)
            if status == 1:
                self.downloads.download(file_id)
        return (file_id, status, filename)

    @dbus.service.method(IFACE, in_signature='as', out_signature='a(sys)')
    def ResolveMany(self, ids):
        result = self.core.resolve_many(ids)
        for (_id, status, filename) in result:
            if status in (0, 1):
                self.lazy_access.access(_id)
        return result

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def AllocateTmp(self):
        return self.core.allocate_tmp()

    @dbus.service.method(IFACE, in_signature='ss', out_signature='a{ss}')
    def HashAndMove(self, tmp, origin):
        return self.core.hash_and_move(tmp, origin)

    @dbus.service.method(IFACE, in_signature='s', out_signature='b')
    def UpdateProject(self, project_id):
        if self.update_thread is not None:
            return False
        project_id = str(project_id)
        log.info('Dmedia.UpdateProject(%r)', project_id)
        assert self.update_thread is None
        self.update_thread = start_thread(self.do_update, project_id)
        return True

    def do_update(self, project_id):
        self.core.update_project(project_id)
        GLib.idle_add(self.on_update_complete)

    def on_update_complete(self):
        self.update_thread.join()
        self.update_thread = None
        if self.pending_update is not None:
            log.info('flushing pending project update')
            self.UpdateProject(self.pending_update)
            self.pending_update = None  

    @dbus.service.method(IFACE, in_signature='s', out_signature='')
    def SnapshotProject(self, project_id):
        project_id = str(project_id)
        log.info('Dmedia.SnapshotProject(%r)', project_id)
        if not self.UpdateProject(project_id):
            self.pending_update = project_id
        self.Snapshot(schema.project_db_name(project_id))
        self.Snapshot(schema.DB_NAME)

    @dbus.service.method(IFACE, in_signature='s', out_signature='')
    def SetAutoFormat(self, value):
        value = str(value)
        log.info('Dmedia.SetAutoFormat(%r)', value)
        self.core.set_auto_format(value)


parser = optparse.OptionParser(
    version=dmedia.__version__,
)
parser.add_option('--bus',
    help='DBus bus name; default is {!r}'.format(BUS),
    default=BUS
)
(options, args) = parser.parse_args()


try:
    busname = dbus.service.BusName(options.bus, session)
    service = Service(busname)
    try:
        service.run()
    finally:
        service.shutdown()
except Exception as e:
    log.exception('Could not start dmedia-service!')
    raise e
log.info('Clean shutdown!')
