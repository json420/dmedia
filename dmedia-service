#!/usr/bin/python3

# dmedia: distributed media library
# Copyright (C) 2011 Novacut Inc
#
# This file is part of `dmedia`.
#
# `dmedia` is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>

"""
Dmedia DBus service on org.freedesktop.Dmedia.
"""

import time
start_time = time.time()

import optparse
import logging
import json

import dbus
import dbus.service
from dbus.mainloop.glib import DBusGMainLoop
from microfiber import Database, NotFound
import usercouch
from gi.repository import GObject

import dmedia
from dmedia.core import Core, start_file_server
from dmedia.service.udisks import UDisks
from dmedia.service.avahi import Avahi


BUS = dmedia.BUS
IFACE = BUS
log = logging.getLogger()

GObject.threads_init()
DBusGMainLoop(set_as_default=True)
session = dbus.SessionBus()


def dumps(obj):
    return json.dumps(obj, sort_keys=True, separators=(',', ': '), indent=4)


class Service(dbus.service.Object):
    usercouch = None
    httpd = None
    avahi = None

    def __init__(self, bus, env_s):
        self.bus = bus
        self.env_s = env_s
        self.mainloop = GObject.MainLoop()
        log.info('DBus: binding to %r', bus)
        super().__init__(session, object_path='/')
        self.busname = dbus.service.BusName(bus, session)

    def start_core(self):
        if self.env_s is None:
            self.usercouch = usercouch.UserCouch(dmedia.get_dmedia_dir())
            env = self.usercouch.bootstrap()
        else:
            env = json.loads(self.env_s)
        self.udisks = UDisks()
        self.core = Core(env, self.udisks.get_parentdir_info)
        self.env_s = dumps(self.core.env)
        if len(self.core.stores) == 0:
            self.core.add_filestore('/home')
        self.udisks.connect('store_added', self.on_store_added)
        self.udisks.connect('store_removed', self.on_store_removed)
        self.udisks.connect('card_added', self.on_card_added)
        self.udisks.connect('card_removed', self.on_card_removed)

    def start_httpd(self):
        (self.httpd, self.port) = start_file_server(self.core.env)
        self.avahi = Avahi(self.core.env, self.port)
        self.avahi.run()

    def run(self):
        self.start_core()
        GObject.timeout_add(500, self.on_idle)
        self.mainloop.run()
        
    def on_idle(self):
        self.udisks.monitor()
        self.start_httpd()
        interval = 5 * 60 * 1000  # Autocompact every 5 minutes
        self._timeout_id = GObject.timeout_add(interval, self._autocompact)
        return False  # Don't repeat idle call

    def _autocompact(self):
        log.info('UserCouch.autocompact()...')
        try:
            for name in self.usercouch.autocompact():
                log.info('compacting %r', name)
        except Exception as e:
            log.exception('Error calling UserCouch.autocompact():')
        return True  # Repeat timeout call

    def kill(self):
        if self.usercouch is not None:
            self.usercouch.kill()
        if self.avahi is not None:
            self.avahi.free()
        if self.httpd is not None:
            self.httpd.terminate()
            self.httpd.join()
        self.mainloop.quit()

    def on_store_added(self, udisks, obj, parentdir, store_id):
        try:
            self.AddFileStore(parentdir)
        except Exception:
            log.exception('Could not add FileStore %r', parentdir)

    def on_store_removed(self, udisks, obj, parentdir, store_id):
        try:
            self.RemoveFileStore(parentdir)
        except Exception:
            log.exception('Could not remove FileStore %r', parentdir)

    def on_card_added(self, udisks, obj, mount, info):
        self.CardAdded(obj, mount, dumps(info))

    def on_card_removed(self, udisks, obj, mount):
        self.CardRemoved(obj, mount)

    @dbus.service.signal(IFACE, signature='sss')
    def CardAdded(self, obj, mount, info):
        pass

    @dbus.service.signal(IFACE, signature='ss')
    def CardRemoved(self, obj, mount):
        pass

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def Version(self):
        """
        Return dmedia version.
        """
        return dmedia.__version__

    @dbus.service.method(IFACE, in_signature='', out_signature='i')
    def Kill(self):
        """
        Kill the `dmedia-service` process.
        """
        self.kill()
        return int(time.time() - start_time)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def GetEnv(self):
        """
        Return dmedia env as JSON string.
        """
        log.info('GetEnv')
        return self.env_s

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def GetDiskInfo(self):
        """
        Return Dmedia-friendly info on disks from UDisks, as a JSON string.
        """
        return dumps(self.udisks.get_info())

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def LocalDmedia(self):
        """
        Return the _local/dmedia doc.
        """
        return dumps(self.core.db.get('_local/dmedia'))

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def LocalPeers(self):
        """
        Return the _local/peers doc.
        """
        return dumps(self.core.db.get('_local/peers')) 

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def AddFileStore(self, parentdir):
        fs = self.core.add_filestore(parentdir)
        return self.LocalDmedia()

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def RemoveFileStore(self, parentdir):
        fs = self.core.remove_filestore(parentdir)
        return self.LocalDmedia()

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def Resolve(self, _id):
        return self.core.resolve(_id)
        
    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def ResolveURI(self, uri):
        return self.core.resolve_uri(uri)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def AllocateTmp(self):
        return self.core.allocate_tmp()

    @dbus.service.method(IFACE, in_signature='ss', out_signature='s')
    def HashAndMove(self, tmp, origin):
        return self.core.hash_and_move(tmp, origin)
        
    


parser = optparse.OptionParser(
	version=dmedia.__version__,
)
parser.add_option('--env',
    help='JSON-encoded CouchDB environment (for unit testing)',
)
parser.add_option('--bus',
    help='DBus bus name; default is {!r}'.format(BUS),
    default=BUS
)
(options, args) = parser.parse_args()


dmedia.configure_logging()
service = Service(options.bus, options.env)
try:
    service.run()
finally:
    service.kill()
