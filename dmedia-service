#!/usr/bin/python3

# dmedia: distributed media library
# Copyright (C) 2011 Novacut Inc
#
# This file is part of `dmedia`.
#
# `dmedia` is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>

"""
Dmedia DBus service on org.freedesktop.Dmedia.
"""

import time
start_time = time.time()

import optparse
import logging
import signal
import multiprocessing

import dbus
import dbus.service
from dbus.mainloop.glib import DBusGMainLoop
from gi.repository import GObject
from microfiber import NotFound, dumps

import dmedia
from dmedia.parallel import start_thread, start_process
from dmedia.startup import DmediaCouch
from dmedia.core import Core, start_httpd, snapshot_worker
from dmedia.service.udisks import UDisks
from dmedia.service.avahi import Avahi
from dmedia.service.peers import Browser, Publisher


BUS = dmedia.BUS
IFACE = BUS
log = logging.getLogger()
GObject.threads_init()
DBusGMainLoop(set_as_default=True)
session = dbus.SessionBus()
mainloop = GObject.MainLoop()


def on_sighup(signum, frame):
    log.info('<SIGHUP>')
    mainloop.quit()

signal.signal(signal.SIGHUP, on_sighup)


class Service(dbus.service.Object):
    couch = None
    httpd = None
    avahi = None
    peer = None
    ui = None
    thread = None
    publisher = None
    env_s = '{}'

    def __init__(self, bus, couch):
        self.bus = bus
        self.couch = couch
        super().__init__(session, object_path='/')
        log.info('DBus: binding to %r', bus)
        self.busname = dbus.service.BusName(bus, session)
        session.call_on_disconnection(self.on_disconnection)
        self.udisks = UDisks()
        self.udisks.connect('store_added', self.on_store_added)
        self.udisks.connect('store_removed', self.on_store_removed)
        self.udisks.connect('card_added', self.on_card_added)
        self.udisks.connect('card_removed', self.on_card_removed)

        self.snapshot_queue_in = multiprocessing.Queue()
        self.snapshot_queue_out = multiprocessing.Queue()
        self.snapshots_in_flight = set()
        self.snapshot_process = None
        self.snapshot_thread = None

    def snapshot_listener(self):
        while True:
            item = self.snapshot_queue_out.get()
            if item is None:
                break
            GObject.idle_add(self.on_snapshot_complete, item)

    def on_snapshot_complete(self, item):
        (dbname, success) = item
        self.snapshots_in_flight.remove(dbname)
        if not self.snapshots_in_flight:
            log.info('No in-flight snapshots, shutting down worker...')
            self.snapshot_queue_in.put(None)
            self.snapshot_process.join()
            self.snapshot_process = None
            self.snapshot_thread.join()
            self.snapshot_thread = None
        self.SnapshotComplete(dbname, success)

    @dbus.service.signal(IFACE, signature='sb')
    def SnapshotComplete(self, dbname, success):
        log.info('@Dmedia.SnapshotComplete(%r, %r)', dbname, success)

    @dbus.service.method(IFACE, in_signature='s', out_signature='b')
    def Snapshot(self, dbname):
        dbname = str(dbname)
        log.info('Dmedia.Snapshot(%r)', dbname)
        if dbname in self.snapshots_in_flight:
            log.warning('Snapshot of %r already in-flight', dbname)
            return False
        self.snapshots_in_flight.add(dbname)
        if self.snapshot_process is None:
            assert self.snapshot_thread is None
            self.snapshot_process = start_process(snapshot_worker,
                self.core.env,
                self.couch.paths.dump,
                self.snapshot_queue_in,
                self.snapshot_queue_out
            )
            self.snapshot_thread = start_thread(self.snapshot_listener)
        self.snapshot_queue_in.put(dbname)
        return True

    @dbus.service.method(IFACE, in_signature='as', out_signature='')
    def SnapshotMany(self, names):
        for dbname in names:
            self.Snapshot(dbname)

    @dbus.service.method(IFACE, in_signature='', out_signature='')
    def SnapshotAll(self):
        log.info('Dmedia.SnapshotAll()')
        for dbname in self.core.server.get('_all_dbs'):
            if dbname.startswith('_') or dbname == 'thumbnails':
                continue
            self.Snapshot(dbname)

    def run(self):
        if self.couch.isfirstrun():
            log.info('First run, not starting CouchDB.')
        else:
            self.start_core()
        mainloop.run()

    def start_core(self):
        start = time.time()
        env = self.couch.auto_bootstrap()
        log.info('%r', self.couch._welcome)
        log.info('Starting CouchDB took %.3f', time.time() - start)
        self.core = Core(env)
        self.core.load_identity(self.couch.machine, self.couch.user)
        self.core.init_default_store()
        if self.core.local.get('default_store') is None:
            self.core.set_default_store('shared')
        self.env_s = dumps(self.core.env, pretty=True)
        log.info('Finished core startup in %.3f', time.time() - start)
        GObject.timeout_add(350, self.on_idle1)

    def on_idle1(self):
        """
        UDisks and peering browser.
        """
        log.info('[idle1 at time %.3f]', time.time() - start_time)
        if self.couch.pki.user.key_file is not None:
            self.peer = Browser(self.couch)
        self.udisks.monitor()
        GObject.timeout_add(350, self.on_idle2)

    def on_idle2(self):
        """
        Init project views, prep project/atime, update project stats.
        """
        log.info('[idle2 at time %.3f]', time.time() - start_time)
        start_thread(self.core.init_project_views)
        GObject.timeout_add(12*1000, self.on_idle3)

    def on_idle3(self):
        """
        HTTPD, Avahi, and replication.
        """
        log.info('[idle3 at time %.3f]', time.time() - start_time)
        ssl_config = self.couch.get_ssl_config()
        (self.httpd, env) = start_httpd(self.core.env, ssl_config)
        port = env['port']
        self.avahi = Avahi(self.core.env, port, ssl_config)
        self.avahi.run()
        GObject.timeout_add(60*1000, self.on_idle4)

    def on_idle4(self):
        """
        Start the background filestore checking tasks.
        """
        log.info('[idle4 at time %.3f]', time.time() - start_time)
        self.core.start_background_tasks()

    def on_disconnection(self, bus):
        log.info('<DBus disconnection>')
        self.shutdown()

    def shutdown(self):
        log.info('Service.shutdown()')
        if self.peer is not None:
            log.info('* freeing peer')
            self.peer.free()
            self.peer = None
        if self.avahi is not None:
            log.info('* freeing avahi')
            self.avahi.free()
            self.avahi = None
        if self.httpd is not None:
            log.info('* killing httpd')
            self.httpd.terminate()
            self.httpd.join()
            self.httpd = None
        if self.couch is not None:
            log.info('* killing usercouch')
            self.couch.kill()
            self.couch = None

    def on_store_added(self, udisks, obj, parentdir, store_id, info):
        try:
            self.core.connect_filestore(parentdir, store_id)
        except Exception:
            log.exception('Could not connect FileStore %r', parentdir)

    def on_store_removed(self, udisks, obj, parentdir, store_id):
        try:
            self.core.disconnect_filestore(parentdir, store_id)
        except Exception:
            log.exception('Could not disconnect FileStore %r', parentdir)

    def on_card_added(self, udisks, obj, mount, info):
        self.CardAdded(obj, mount, dumps(info))

    def on_card_removed(self, udisks, obj, mount):
        self.CardRemoved(obj, mount)

    @dbus.service.signal(IFACE, signature='sss')
    def CardAdded(self, obj, mount, info):
        pass

    @dbus.service.signal(IFACE, signature='ss')
    def CardRemoved(self, obj, mount):
        pass

    @dbus.service.signal(IFACE, signature='s')
    def Message(self, message):
        log.info('@Dmedia.Message(%r)', message)

    @dbus.service.signal(IFACE, signature='')
    def Accept(self):
        log.info('@Dmedia.Accept()')

    @dbus.service.signal(IFACE, signature='b')
    def Response(self, success):
        log.info('@Dmedia.Response(%r)', success)

    @dbus.service.signal(IFACE, signature='')
    def InitDone(self):
        log.info('@Dmedia.InitDone()')

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def Version(self):
        """
        Return dmedia version.
        """
        return dmedia.__version__

    @dbus.service.method(IFACE, in_signature='', out_signature='b')
    def NeedsInit(self):
        """
        Return True if we need to do the firstrun init.
        """
        return self.couch.user is None

    @dbus.service.method(IFACE, in_signature='', out_signature='b')
    def CreateUser(self):
        log.info('Dmedia.CreateUser()')
        if self.couch.user is not None:
            return False
        if self.thread is not None:
            return False
        self.Message('Creating user certificate...')
        self.thread = start_thread(self.create_user)
        return True

    def create_user(self):
        log.info('create_user()')
        self.couch.create_user()
        GObject.idle_add(self.Message, 'Starting CouchDB...')
        self.start_core()
        GObject.idle_add(self.on_init_done)

    def on_init_done(self):
        log.info('on_init_done()')
        self.thread.join()
        self.thread = None
        if self.publisher is not None:
            self.publisher.free()
            self.publisher = None
        self.Message('Done!')
        GObject.timeout_add(500, self.InitDone)

    @dbus.service.method(IFACE, in_signature='', out_signature='b')
    def PeerWithExisting(self):
        log.info('Dmedia.PeerWithExisting()')
        if self.couch.user is not None:
            return False
        if self.publisher is not None:
            return False
        self.publisher = Publisher(self, self.couch)
        GObject.idle_add(self.publisher.run)
        return True

    @dbus.service.method(IFACE, in_signature='s', out_signature='b')
    def SetSecret(self, secret):
        log.info('Dmedia.SetSecret()')
        return self.publisher.set_secret(secret)

    def set_user(self, user_id):
        log.info('set_user(%r)', user_id)
        assert self.couch.user is None
        assert self.thread is None
        self.Message('Starting CouchDB...')
        self.thread = start_thread(self._set_user, user_id)

    def _set_user(self, user_id):
        self.couch.set_user(user_id)
        self.start_core()
        GObject.idle_add(self.on_init_done)

    @dbus.service.method(IFACE, in_signature='', out_signature='i')
    def Kill(self):
        """
        Kill the `dmedia-service` process.
        """
        log.info('Service.Kill()')
        mainloop.quit()
        return int(time.time() - start_time)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def GetEnv(self):
        """
        Return dmedia env as JSON string.
        """
        log.info('Service.GetEnv()')
        return self.env_s

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def GetDiskInfo(self):
        """
        Return Dmedia-friendly info on disks from UDisks, as a JSON string.
        """
        return dumps(self.udisks.info)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def LocalDmedia(self):
        """
        Return the _local/dmedia doc.
        """
        return dumps(self.core.db.get('_local/dmedia'))

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def Peers(self):
        """
        Return the _local/peers doc.
        """
        try:
            doc = self.core.db.get('_local/peers')
            return dumps(doc['peers'], pretty=True)
        except NotFound:
            return '{}'

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def CreateFileStore(self, parentdir):
        parentdir = str(parentdir)
        log.info('Dmedia.CreateFileStore(%r)', parentdir)
        self.core.create_filestore(parentdir)
        return self.LocalDmedia()

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def SetDefaultStore(self, value):
        value = str(value)
        log.info('Dmedia.SetDefaultStore(%r)', value)
        self.core.set_default_store(value)
        return self.LocalDmedia()

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def Resolve(self, _id):
        return self.core.resolve(_id)

    @dbus.service.method(IFACE, in_signature='s', out_signature='s')
    def ResolveURI(self, uri):
        return self.core.resolve_uri(uri)

    @dbus.service.method(IFACE, in_signature='', out_signature='s')
    def AllocateTmp(self):
        return self.core.allocate_tmp()

    @dbus.service.method(IFACE, in_signature='ss', out_signature='a{ss}')
    def HashAndMove(self, tmp, origin):
        return self.core.hash_and_move(tmp, origin)

    @dbus.service.method(IFACE, in_signature='s', out_signature='')
    def UpdateProjectStats(self, project_id):
        project_id = str(project_id)
        log.info('Dmedia.UpdateProjectStats(%r)', project_id)
        self.core.update_project_stats(project_id)


parser = optparse.OptionParser(
	version=dmedia.__version__,
)
parser.add_option('--bus',
    help='DBus bus name; default is {!r}'.format(BUS),
    default=BUS
)
(options, args) = parser.parse_args()


# Before we do anything else, aquire the UserCouch lock:
couch = DmediaCouch(dmedia.get_dmedia_dir())

# Now go for it:
dmedia.configure_logging()
try:
    if couch.machine is None:
        couch.create_machine()
    service = Service(options.bus, couch)
    try:
        service.run()
    finally:
        service.shutdown()
except Exception as e:
    log.exception('Could not start dmedia-service!')
    raise e
