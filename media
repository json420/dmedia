#!/usr/bin/env python

# Authors:
#   Jason Gerard DeRose <jderose@jasonderose.org>
#
# dmedia: distributed media library
# Copyright (C) 2010 Jason Gerard DeRose <jderose@jasonderose.org>
#
# This file is part of `dmedia`.
#
# `dmedia` is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.


"""
This will eventually be turned into a VCS-style script with several commands.
For now it has a single function, to recursively import media files from a
directory.  At this point, is is a quick-and-dirty demo of how media files might
be stored and how their meta-data might be stored.

For example, say we scan all the JPEG images in the '/usr/share/backgrounds'
directory:

    media /usr/share/backgrounds jpg

Media files are uniquely ID'ed by their sha224 content-hash.  In the above
example, the 'SmoothMoment.jpg' file happens to have a sha224 content-hash of
'64786ca5b2f897ae2c59ecac69211e24240c2271ef5e9e9365e2c901'.  As such, this file
will be stored at:

    ~/.local/share/media/64/786ca5b2f897ae2c59ecac69211e24240c2271ef5e9e9365e2c901

Meta-data for the media files is stored in couchdb using desktop-couch.  Each
media file has its own document.  The sha224 content-hash is used as the
document '_id'.  For example, the 'SmoothMoment.jpg' file has a document that
looks like this:

    {
       "_id": "64786ca5b2f897ae2c59ecac69211e24240c2271ef5e9e9365e2c901",
       "_rev": "1-bae6f22d07bab978a78a635609d886ab",
       "ext": "jpg",
       "height": 1280,
       "mtime": 1271278433,
       "name": "SmoothMoment.jpg",
       "record_type": "http://example.com/media",
       "size": 106425
       "width": 1920,
    }

All media files will have the following fields:

    size - Size of file in bytes
    mtime - Value of path.getmtime() at time of import
    name - The path.basename() part of the original source file
    ext - The extension of the original source file, normalized to lower-case

Additional fields depend upon the type of media file.  For example, image and
video files will always have 'width' and 'height', whereas video and audio files
will always have a 'duration'.
"""

import sys
import os
from os import path
import optparse
import medialib
from medialib.filestore import FileStore
from medialib.metastore import MetaStore
from medialib.extractor import merge_metadata

BATCH_SIZE = 400

script = path.basename(sys.argv[0])

parser = optparse.OptionParser(
	version=medialib.__version__,
	usage='Usage: %s DIRECTORY EXTENSIONS...' % script,
	epilog='Example: %s /media/EOS_DIGITAL jpg cr2' % script,
)
parser.add_option('--quick',
	action='store_true',
	default=False,
	help='Do a fast scan without extracting extra metadata',
)

(options, args) = parser.parse_args()

if len(args) < 2:
    parser.print_usage()
    sys.exit('ERROR: must provide DIRECTORY and at least one EXTENSION')
base = path.abspath(args[0])
if not path.isdir(base):
    parser.print_usage()
    sys.exit('ERROR: not a directory: %r' % base)
extensions = frozenset(a.lower() for a in args[1:])

store = FileStore()
db = MetaStore()




buf = []
total = 0
counts = {}
for d in store.add_recursive(base, extensions):
    print '  %(action)s %(src)r' % d
    action = d['action']
    counts[action] = counts.get(action, 0) + 1
    total += 1
    if not action.startswith('skipped'):
        if not options.quick:
            merge_metadata(d)
        buf.append(db.new(d['meta']))
    if len(buf) >= BATCH_SIZE:
        db.db.put_records_batch(buf)
        buf = []
if buf:
    db.db.put_records_batch(buf)

print ''
for key in sorted(counts):
    print '%s: %d' % (key, counts[key])
print 'total_scanned: %d' % total
