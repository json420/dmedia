#!/usr/bin/env python

# Authors:
#   Jason Gerard DeRose <jderose@jasonderose.org>
#
# media: distributed media library
# Copyright (C) 2010 Jason Gerard DeRose <jderose@jasonderose.org>
#
# This file is part of `media`.
#
# `media` is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# `media` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with `media`.  If not, see <http://www.gnu.org/licenses/>.


"""
10 - 5111906 - 1306722
100 - 2703458 - 1306722

100 (short id) - 2269282 - 1101922

400 - 1667170 - 1302626
400 (with exif) - 2003042 - 1634402
400 (sep ext) - 1998946 - 1646690

1000 - 1310818 - 1306722
"""


import sys
import os
from os import path
import optparse
import medialib
from medialib.filestore import FileStore
from medialib.metastore import MetaStore
from medialib.extractor import merge_metadata

script = path.basename(sys.argv[0])

parser = optparse.OptionParser(
	version=medialib.__version__,
	usage='Usage: %s DIRECTORY EXTENSIONS...' % script,
	epilog='Example: %s /media/EOS_DIGITAL jpg cr2' % script,
)
parser.add_option('--quick',
	action='store_true',
	default=False,
	help='Do a fast scan without extracting extra metadata',
)

(options, args) = parser.parse_args()

if len(args) < 2:
    parser.print_usage()
    sys.exit('ERROR: must provide DIRECTORY and at least one EXTENSION')
base = path.abspath(args[0])
if not path.isdir(base):
    parser.print_usage()
    sys.exit('ERROR: not a directory: %r' % base)
extensions = frozenset(a.lower() for a in args[1:])

store = FileStore()
db = MetaStore()

BATCH_SIZE = 400


buf = []
total = 0
counts = {}
for d in store.add_recursive(base, extensions):
    print '  %(action)s %(src)r' % d
    action = d['action']
    counts[action] = counts.get(action, 0) + 1
    total += 1
    if not action.startswith('skipped'):
        if not options.quick:
            merge_metadata(d)
        buf.append(db.new(d['meta']))
    if len(buf) >= BATCH_SIZE:
        db.db.put_records_batch(buf)
        buf = []
if buf:
    db.db.put_records_batch(buf)

print ''
for key in sorted(counts):
    print '%s: %d' % (key, counts[key])
print 'total_scanned: %d' % total
