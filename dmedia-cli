#!/usr/bin/python3

# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>
#   David Green <david4dev@gmail.com>
#
# dmedia: distributed media library
# Copyright (C) 2010, 2011 Jason Gerard DeRose <jderose@novacut.com>
#
# This file is part of `dmedia`.
#
# `dmedia` is free software: you can redistribute it and/or modify it under the
# terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.


"""
Command line tool for talking to dmedia DBus services.
"""

import optparse
from collections import OrderedDict
import sys
from gettext import ngettext
from os import path

import dbus

import dmedia
from dmedia.units import minsec


methods = OrderedDict()
session = dbus.SessionBus()


def error(msg, code=1):
    print('ERROR:', msg)
    sys.exit(code)


def print_methods():
    width = max(len(name) for name in methods)
    print('DBus methods on {}:'.format(dmedia.BUS))
    for name in methods:
        if name == 'futon':
                print('')
                print('Misc commands:')
        cls = methods[name]
        print('  {}  {}'.format(name.ljust(width), cls.__doc__))


def print_usage(cls):
    print('Usage:')
    print(' ', *cls.usage())


class MethodMeta(type):
    def __new__(meta, name, bases, dict):
        cls = type.__new__(meta, name, bases, dict)
        if not name.startswith('_'):
            methods[name] = cls
        return cls


class _Method(metaclass=MethodMeta):
    args = tuple()

    def __init__(self, bus):
        self.bus = bus
        self.proxy = session.get_object(bus, '/')

    @classmethod
    def usage(cls):
        script = path.basename(sys.argv[0])
        cmd = [script, cls.__name__]
        cmd.extend(arg.upper() for arg in cls.args)
        return cmd

    def run(self, args):
        args = self.validate_args(*args)
        method = self.proxy.get_dbus_method(self.__class__.__name__)
        return self.format_output(method(*args))

    def validate_args(self, *args):
        return args

    def format_output(self, output):
        return output


class Version(_Method):
    'Show version of running `dmedia-service`'


class Kill(_Method):
    'Shutdown `dmedia-service`'
    
    def format_output(self, seconds):
        return '{} was running for {}'.format(self.bus, minsec(seconds))


class GetEnv(_Method):
    'Get the CouchDB and Dmedia environment info'
    

class GetDiskInfo(_Method):
    'Get info on drives and partitions from UDisks'


class LocalDmedia(_Method):
    'Get the _local/dmedia document (shows file-stores)'


class LocalPeers(_Method):
    'Get the _local/peers document'


class CreateFileStore(_Method):
    'Create a new FileStore'

    args = ['directory']
    
    def validate_args(self, directory):
        return [path.abspath(directory)]


class SetDefaultStore(_Method):
    "Set default store to 'private', 'shared', or 'none'"

    args = ['value']


class Resolve(_Method):
    'Resolve Dmedia file ID into a regular file path'

    args = ['file_id']


class ResolveURI(_Method):
    'Resolve a Dmedia URI into a file URI'

    args = ['uri']


class AllocateTmp(_Method):
    'Allocate a temporary file for rendering or import'


class HashAndMove(_Method):
    'Allocate a temporary file for rendering or import'

    args = ['tmp_filename']


def get_authurl(env):
    if 'basic' not in env:
        return env['url']
    return 'http://{}:{}@localhost:{}/'.format(
        env['basic']['username'],
        env['basic']['password'],
        env['port']
    )


class futon(_Method):
    'Open CouchDB Futon UI in default web browser'

    def run(self, args):
        import json
        import subprocess
        env = json.loads(self.proxy.GetEnv())
        url = get_authurl(env) + '_utils/'
        subprocess.check_call(['/usr/bin/xdg-open', url])
        return url


parser = optparse.OptionParser(
    usage='%prog METHOD [ARGS...]',
	version=dmedia.__version__,
)
parser.add_option('--bus',
    help='DBus bus name; default is {!r}'.format(dmedia.BUS),
    default=dmedia.BUS
)
(options, args) = parser.parse_args()


if len(args) == 0:
    parser.print_help()
    print('')
    print_methods()
    sys.exit(0)

name = args[0]
args = args[1:]
if name not in methods:
    print_methods()
    print('')
    error('Unknown method {!r}'.format(name))

cls = methods[name]
if len(args) != len(cls.args):
    print_usage(cls)
    print('')
    msg = ngettext(
        '{!r} takes exactly {} argument',
        '{!r} takes exactly {} arguments',
        len(cls.args)
    )
    error(msg.format(name, len(cls.args)))

method = cls(options.bus)
print(method.run(args))
